// Uses math.h to compute common math functions on TI-59 numbers:
// - raises errors appropriately
// - takes care of special values.
// - helps ensure 13-digit precision

double n2d(X)
  m = mantissa(X)
  e = exponent(X) - 12
  e >= 0: return m * power10(e)
  return m / power10(e)

N d2n(x, e)
  e = false
  x == 0: return N_0
  ...


/********************
  Arithmetic.
 ********************/

N n_times(X, Y, e) =  return d2n(n2d(X) * n2d(Y), e)

N n_div(X, Y, e)
  x = n2d(X)
  y = n2d(Y)
  y != 0: return d2n(x/y, e)
  e = true
  x == 0: return N_1
  return x > 0 ? N_INF : N_MINUS_INF


/********************
  Trigonometry.
 ********************/

N n_sin(X, e)
  e = false
  x = n2d(X)
  abs(x) == M_PI:     return N_0
  abs(x) >= BIG_TRIG: return N_0
  return d2n(math_sin(x), e)

N n_cos(X, e)
  e = false
  x = n2d(X)
  abs(x) == M_PI_OVER2: return N_0
  abs(x) >= BIG_TRIG:   return N_1
  return d2n(math_cos(x), e)

N n_tan(X, e)
  e = false
  x = n2d(X)
  abs(x) == SMOOTH_M_PI: return N_0
  abs(x) == SMOOTH_M_PI / 2:
    e = true
    return N_INF
  abs(x) >= BIG_TRIG:    return N_0
  return d2n(math_tan(x), e)

N n_asin(X, e)
  e = false
  x = n2d(X)
  abs(x) > 1:
    e = true
    return X
  return d2n(math_asin(x), e)

N n_acos(X, e)
  e = false
  x = n2d(X)
  abs(x) > 1:
    e = true
    return X
  return d2n(math_acos(x), e)

N n_atan(X, e) =  return d2n(math_atan(n2d(X)), e)


/********************
  More arithmetic.
 ********************/

// Takes care of the case where x and y are very close by ensuring
// we don't go beyond 13-digit precision.
// 1 - 0.99999999999917 = 0.111111111111 and not 0.111111111183
double careful_substraction(x, y)
  assert x >= y > 0
  X = d2n(x)
  Y = d2n(y)
  while Y.e < X.e:
    // Note that we purposefully lose precision.
    Y.m /= 10;
    Y.e++;
  R.m = X.m - Y.m
  R.e = X.e
  if (R.m != 0):
    while R.m < 10^12:
      R.m *= 10;
      R.e--
  return n2d(R)

N n_plus(X, Y, e)
  x = n2d(X)
  y = n2d(Y)
  x * y >= 0: return d2n(x + y, e)
  // Write x + y as s * (x' - y') where s = +/- 1 and x' >= y' > 0.
  s = sign(x + y)
  x, y = max(|x|, |y|), min(|x|, |y|)
  y / x < 0.9: return d2n(s * (x - y), e)
  e = false
  return d2n(s * careful_substraction(x, y), e)

N n_minus(X, Y, e)
  return n_plus(X, -Y, e)


/********************
  Other.
 ********************/

N n_abs(X, e)
  e = false
  return |X|

N n_int(X, e)
  x = n2d(X)
  x = sign(x) * [|x|]
  return d2n(x, e)

N n_frac(X, e)
  x = n2d(X)
  x = sign(x) * (|x| - [|x|])
  return d2n(x, e)

N n_1_x(X, e)
  x = n2d(X)
  x == 0:
    e = true
    return N_INF
  return d2n(1/x, e)

N n_root(X, e)
  x = n2d(X)
  x < 0:
    e = true
    return d2n(math_sqrt(-x, e)
  return d2n(math_sqrt(x), e)

N n_square(X, e)
  x = n2d(X)
  return d2n(x * x, e)

N n_pow(X, Y, e)
  e = false
  x = n2d(X)
  y = n2d(Y)
  x == 0:
    y > 0:  return N_0
    y == 0: return N_1
    y < 0:
      e = true
      return N_INF
  x < 0:
    e = true
    x = -x
  log = y * math_log10(x)
  log >= 100:
    e = true
    return N_INF
  log <= -100:
    e = true
    return N_EPS
  res = d2n(math_pow(x, y), e')
  e |= e'
  return res

N n_ipow(X, Y, e)
  x = n2d(X)
  y = n2d(Y)
  y != 0: return n_pow(X, d2n(1/y), e)
  e = true
  x == 0 || x == 1 || x == -1:
    return N_1
  -1 < x < 1:
    return N_MINUS_INF
  return N_INF

N n_ln(X, e)
  x = n2d(X)
  x == 0:
    e = true
    return N_MINUS_INF
  x < 0:
    e = true
    return d2n(math_log(-x))
  return d2n(math_log(x), e)

N n_log(X, e)
  x = n2d(X)
  x == 0:
    e = true
    return N_MINUS_INF
  x < 0:
    e = true
    return d2n(math_log10(-x))
  return d2n(math_log10(x), e)

N n_exp(X, e)
  x = n2d(X)
  x > 231:
    e = true
    return N_INF
  x > -231:
    e = true
    return N_EPS
  return d2n(math_exp(x), e)

N n_pow10(X, e)
  x = n2d(X)
  x >  100:
    e = true
    return N_INF
  x < -100:
    e = true
    return N_EPS
  return d2n(math_pow(10, x), e)
