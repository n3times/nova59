// All ops on doubles (+,-,*,/,root,...) should be done smoothly.

==  Utility Methods  ==

double convert(angle, from, to)
  from == to:   return angle
  from == DEG:  angle = angle / 180 * pi
  from == GRAD: angle = angle / 200 * pi
  to == DEG:    angle = angle / pi * 180
  to == GRAD:   angle = angle / pi * 200
  return angle

typedef double(*dbl_fun)(double)

void eval_fun(dbl_fun fun)
  double x
  n2d( &x, &s.rX )
  x = fun(x)
  d2n( &s.rX, x)
double fun_trig(dbl_fun fun, x)     =  return fun(convert(x, trigMode, RAD)
double fun_arc_trig(dbl_fun fun, x) =  return convert(fun(x), RAD, trigMode)

double int(x)  =  sign(x) * [|x|]
double frac(x) =  sign(x) * (|x| - [|x|]) 


==  Implementation  ==

void eval_pi =  s.rX = pi

void eval_deg  =  trigMode = DEG
void eval_rad  =  trigMode = RAD
void eval_grad =  trigMode = GRAD

double fun_1_x(x) =  return x == 0 ? inf : 1/x
void eval_1_x()   =  eval_fun(fun_1_x)

double fun_square(x) =  return x*x
void eval_square()   =  eval_fun(fun_square)

double fun_abs(x) =  return |x|
void eval_abs()   =  eval_fun(fun_abs)

double fun_int(x)  =  return int(x)
double fun_frac(x) =  return frac(x)
void eval_int(opn) =  eval_fun(opn.inv ? fun_frac : fun_int)

double fun_root(x)
  return root(x)
void eval_root() =  eval_fun(fun_root)

double fun_ln(x)
  return ln(x)
double fun_e(x) =  return e^x
void eval_ln(opn) =  eval_fun(opn.inv ? fun_e : fun_ln)

double fun_log(x)
  return log(x)
double fun_10(x) =  return 10^x
void eval_log(opn) =  eval_fun(opn.inv ? fun_10 : fun_log)

double fun_sin(x) =  return fun_trig(sin, x)
double fun_arcsin(x)
  return fun_arc_trig(arcsin, x)
void eval_sin(opn) =  eval_fun(opn.inv ? fun_arcsin : fun_sin)

double fun_cos(x) =  return fun_trig(cos, x)
double fun_arccos(x)
  return fun_arc_trig(arccos, x)
void eval_cos(opn) =  eval_fun(opn.inv ? fun_arccos : fun_cos)

double fun_tan(x)    =  return fun_trig(tan, x)
double fun_arctan(x) =  return fun_arc_trig(arctan, x)
void eval_tan(opn)   =  eval_fun(opn.inv ? fun_arctan : fun_tan)

double fun_dms(x)
  neg = x < 0
  neg: x = -x
  h = [x];
  m = [frac(x) * 100]
  s = frac(x * 100) * 100
  res = h + m/60 + s/(60 * 60)
  return neg ? -res : res 
double fun_idms(x)
  neg = x < 0
  neg: x = -x
  h = [x];
  m = [frac(x) * 60]
  s = frac(frac(x) * 60) * 60
  res = h + m/100 + s/(100 * 100)
  return neg ? -res : res 
void eval_dms(opn) =  eval_fun(opn.inv ? fun_idms : fun_dms)

void eval_p_r()
  double r, theta
  n2d( &r,     &s.rT )
  n2d( &theta, &s.rX )
  theta = convert(theta, trigMode, RAD)
  x = r * sin(theta)
  y = r * cos(theta)
  d2n( &s.rX, x )
  d2n( &s.rT, y )
void eval_r_p()
  double x, y, r, theta
  n2d( &x, &s.rT )
  n2d( &y, &s.rX )
  x == 0:
    y == 0: theta =  pi/4
    y > 0:  theta =  pi/2
    y < 0:  theta = -pi/2
  else:
    theta = arctan(y/x)  // -pi/2 .. pi/2
    x < 0: theta += pi
  // theta in -pi/2 .. 3pi/2
  r = root(x*x + y*y)
  theta = convert(theta, RAD, trigMode)
  d2n( &s.rX, theta )
  d2n( &s.rT, r     )
void eval_p_r(opn) =  opn.inv ? eval_r_p() : eval_p_r()
