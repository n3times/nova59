// Arithmetic.
double smooth_times(x, y) =  return x * y

double smooth_divide(x, y)
  y != 0: return x/y
  s.err = true
  x == 0: return 1
  x > 0: return inf
  return -inf

double careful_substraction(x, y)
  // x >= y > 0
  N *X, *Y, *R
  d2n(&X, x)
  d2n(&Y, y)
  while (Y.e < X.e) {
    Y.m /= 10;
    Y.e++;
  }
  R.m = X.m - Y.m
  R.e = X.e;
  if (R.m != 0) {
    while (R.m < POWER_10[12]) {
      R.m *= 10;
      R.e--;
    }
  }
  n2d(&r, &R)
  return r

double smooth_plus(x, y)
  x * y >= 0: return x + y
  // xy < 0.
  |x| < |y|: return smooth_plus(y, x)
  // |x| >= |y|.
  x < 0: return -smooth_plus(-x, -y)
  // x > 0 && y < 0 && |x| >= |y|.
  -y / x < 0.9: return x + y
  return careful_substraction(x, -y)

double smooth_minus(x, y)
  return smooth_plus(x, -y)


// Trigonometry.
double smooth_sin(x)
  abs_x = x > 0 ? x : -x;
  abs_x == SMOOTH_M_PI: return 0
  abs_x >= BIG_TRIG:    return 0
  return math_sin(x);

double smooth_cos(x)
  abs_x = x > 0 ? x : -x;
  abs_x == SMOOTH_M_PI / 2: return 0
  abs_x >= BIG_TRIG:        return 1
  return math_cos(x);

double smooth_tan(x)
  abs_x = x > 0 ? x : -x;
  abs_x == SMOOTH_M_PI:     return 0
  abs_x == SMOOTH_M_PI / 2: return inf
  abs_x >= BIG_TRIG:        return 0
  return math_tan(x);

double smooth_asin(x)
  x < -1 || x > 1:
    s.err = true
    return x
  return math_asin(x);

double smooth_acos(x)
  x < -1 || x > 1:
    s.err = true
    return x
  return math_acos(x);

double smooth_atan(x)
  return math_atan(x);

// Other.
double smooth_root(x)
  x < 0:
    s.err = true
    x = -x
  return math_sqrt(x)

double smooth_pow(x, y)
  x < 0:
    s.err = true
    x = -x
  x == 0:
    b > y: return 0
    y == 0: return 1
    return inf
  log = y * math_log10(x)
  log >= 100:
    s.err = true
    return inf
  log <= -100
    s.err = true
    return eps
  return math_pow(x, y)

double smooth_ipow(x, y)
  y != 0: return smooth_pow(x, 1/y)
  s.err = true
  x == 0 || x == 1 || x == -1: return 1
  -1 < x < 1: return -inf
  return inf

double smooth_ln(x)
  x == 0:
    s.err = true
    return -inf
  x < 0:
    s.err = true
    x = -x
  return math_log(x)

double smooth_log(x)
  x == 0:
    s.err = true
    return -inf
  x < 0:
    s.err = true
    x = -x
  return math_log10(x)
