==  Evaluator in EVAL/SST/RUN Modes  ==

bool is_numeric_opn(opn)  =  opn.opr.key in { 0, ..., 9, ., +/-, EE }
bool is_program_edit_opn(opn)  =  opn.opr.key in { LRN, SST, BST, INS, DEL }

==  API  ==

Evaluator
  Operation operations[]
  int last_resolved_opn_index = -1  // Complete or canceled.
  Log log

  Evaluator new_evaluator(Operation[], Log)

  void eval_completed_operations()

==  Implementation  ==

void eval_completed_operations()
  opns = operations
  for opn_index = last_resolved_opn_index + 1;
      opn_index <= opns.len - 1;
      opn_index++:
    opn = opns[opn_index]
    key = opn.operator.key

    log_input = is_log_mode(mode)

    // Display may need to be evaled even if operation is not complete yet.
    do_eval_display = state.is_display_edit &&
                      key != KEY_UNK &&
                      key_data[key].does_eval_display
    do_eval_display:
      log_input: log.input(state.display)
      state.display.eval()

    // Eval operation.
    opn.state == COMPLETE:
      opn.eval()
      log_output = is_log_mode(mode)
      is_number_edit_opn = is_numeric_opn(opn) && state.is_display_edit
      is_loggable_opn = !is_number_edit_opn && !is_program_edit_opn(opn)
      is_loggable_opn:
        log_input && state.is_display_edit: log.input(state.display)
        log_input: log.input(opn)
        log_output: log.output(state.display)

    opn.state != PENDING:
      last_resolved_opn_index = opn_index

  is_log_mode(mode): log.pending(get_pending_operation)
  update_current_operation()

String get_pending_operation()
  state.is_display_edit: return state.display
  opns = parser_operations
  int last_opn_index = opns.operations.len - 1
  return operation_as_string(opn[last_opn_index])
