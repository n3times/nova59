== OPERATION PRINTING ==

string print_operand(Operand opd)
  opd.type == LBL: return key_data[int(opd.value)].as_string
  else:            return (opd.type == IND ? "*" : "") + opd.value

string print_operation(Operation opn)
  str = ""

  // Operator.
  opr = opn.operator
  opr.inv: str += "INV "
  opr.key != KEY_UNK: str += key_data[opr.key].as_string

  // Operands.
  opr.operands.length > 0: str += " " + print_operand(opn.operands[0])
  opr.operands.length > 1: str += " " + print_operand(opn.operands[1])

  opn.is_complete: return str
  opn.is_canceled: return str + " X"
  opn.is_pending:  return str + "_"


== OPERATION EVALUATION IN EVAL/SST/RUN MODES ==

State
  OpnLog allOperationsLog       // Unlimited list of complete operations.
  OpnLog completeOperationsLog  // Unlimited list of all operations.
  CurrentOon currentOperation   // Current operation.
  int last_evaled_index = -1
  Parser parser = new_parser()

// EVAL
void on_key_pressed(int i, int j):
  parser.handle_key_pressed(MODE_EVAL, i, j)
  eval_opns()

// SST / RUN
void on_handle_step(Mode mode, int step):
  assert mode in { MODE_RUN, MODE_SST }
  parser.handle(mode, step)
  eval_opns()

void eval_opns()
  opns = parser.operations
  for opn_index = last_evaled_index+1; opn_index <= opns.length-1; opn_index++:
    opn = opns[opn_index]
    opr = opn.operator

    // Eval display.
    do_eval_display = state.is_display_edit &&
                      opr != KEY_UNK &&
                      key_data[opr.key].does_eval_display
    do_eval_display: state.display.eval()

    // Eval operation.
    opn.is_complete:
      opn.eval()
      last_evaled_index = opn_index;

    // Log operation.
    printed_opn = print_operation(opn)
    !opn.is_pending: allOperationsLog.add(printed_opn)
    opn.is_complete: completeOperationsLog.add(printed_opn)
    opn.is_pending: currentOperation.set(printed_opn)
