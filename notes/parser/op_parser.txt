Parser


== API ==

// Given a stream of key presses and program steps, the parser generates a
// stream of operations, each one with its operator and arguments. In addition,
// the parser provides information about those keys and steps.
// The parser is used by the engine to carry out those operations. It can also
// be used for logging, to map key strokes to steps in LRN mode and to show the
// structure of a program.
Parser
  Operation operations[]   // An ever growing array. Last/current may be empty.

  bool sec                 // 2nd modifier for operator or argument

  // Updates the parser after the key (row, col) has been pressed, in EVAL or
  // LRN modes.
  // Params: 1 <= row <= 9, 1 <= col <= 5.
  // Returns the type of key that has been pressed, taking into account the
  // 2nd modifier.
  Key keyPressed(int row, int col)

  // Updates the parser after the step has been handled, in RUN or SST modes.
  // Param: 0 <= code <= 99.
  // Returns the type of step.
  Code handleStep(int code)

Code
  KeyType type
  int value

KeyType
  enum:
    // OPERATOR
    KEY_MOD_INV
    KEY_OP

    // ARGUMENT
    KEY_MOD_IND
    KEY_ARG_NUM
    KEY_ARG_LBL

    // MISC
    KEY_LBL_BEG
    KEY_LBL_ARG
    KEY_IGNORED  // 2ND, 2N', IND, NOP, LBL or SST

Operation
  ParseState parse_state
  Operator operator
  Arg args[]      // A growing array of length 0, 1 or 2

ParseState
  enum:
    OPERATOR      // Operator hasn't been determined yet
    ARG_UNK       //
    ARG_IND       //
    SKIP_LBL      //
    LAST_DD       //  
    LAST_D        //  
    ADDRESS       //
    COMPLETE      // Operators and arguments have been fully determined

Operator
  bool inv
  int code        // 0 to 99

Arg
  ArgType type    // Indicates how to interpret the argument value
  int value       // 0 to 999: opcode for label or address or register...

ArgType
  enum:
    UNK           // Type so far unknown. Value doesn't have any meaning
    IND           // Value is the indirect register
    LBL           // Value is the code of a label
    NUM           // Value is the index of a register, flag or step

ArgKind
  enum:
    ARG_KIND_ADDRESS  // DDD, *DD or LBL
    ARG_KIND_D        // D or *DD
    ARG_KIND_DD       // DD (or *DD in EVAL/LRN modes)
    ARG_KIND_SBR      // usr or SBR address

== Helper functions ==

// From key/step to operator.
// Not all combinations of inv/sec/step/key are operators:
// - modifiers (2nd, INV, Ind) are not operators
// - modifiers 2n', IN' (RUN mode) are not operators
// - NOP is not an operator
// - SST is not an operator in RUN mode
// Everything else in an operator:
// - we consider 2nd CLR as an operator identical to CLR
// - we consider all straight operators to have an inv version
//   (possibly identical to the straight one)

// EVAL mode.
bool is_dig(bool sec, int row, int col)  // !2nd 62,63,64,72,73,74,82,83,84,92
int get_code(bool sec, int row, int col)
int get_dig(int row, int col)

// RUN mode.
bool is_usr(int step)                    // 10 to 19

// Possible argument types for a given operator.
int arg_count(Operator operator)  // 0, 1 or 2

void cancel_operation()
  add new empty operation   // Previous operation remains incomplete
  keyPressed(row, col)      // Preserving sec

void done_arg()
  if current operation has additional args
    add new arg
  else
    current_operation.parse_state = COMPLETE
    add new empty operation

void done_arg_requeue()
  done_arg()
  handleStep(step) or keyPressed(row, col)  // Preserving sec


== Implementation ==

KeyType keyPressed(int row, int col)
  assert row in 1..9 && col in 1..5

  // Some definitions
  opn = operations.last
  opr = opn.operator

  is(2nd): ~opn.sec                                                 KEY_MOD_2ND

  case opn.parse_state:
    COMPLETE:
      assert(false)
    OPERATOR:

    // Condition             new inv|code            new state      ret_value

      is(INV):               ~inv|.                  .              KEY_MOD_INV
      is_op(.):              .|get_code(.)           [ DONE_OPR ]   KEY_OP
      is(LBL):                                       SKIP_LBL       KEY_LBL_BEG
      else:  // Skip Ind, Nop                                       KEY_IGNORED
    SKIP_LBL:                                        OPERATOR       KEY_LBL_ARG

    // Condition             new type|value          new state      ret_value

    ARG_UNK:
      is(Ind):               IND|.                   ARG_IND        KEY_MOD_IND
      is_dig(.):
        kind_is(ADDRESS):    NUM|get_dig(.)          LAST_DD        KEY_ARG_NUM
        kind_is(DD):         NUM|get_dig(.)          LAST_D         KEY_ARG_NUM
        kind_is(D):          NUM|get_dig(.)          [ DONE_ARG ]   KEY_ARG_NUM
      is_label(.) &&
          kind_is(ADDRESS):  LBL|get_code(.)         [ DONE_ARG ]   KEY_ARG_LBL
      else:                                          [ CANC_OPN ]   [ RE_KEY ]
    ARG_IND:
      is(Ind):               UNK|.                   ARG_UNK        KEY_MOD_IND
      is_dig(.):             .|get_dig(.)            LAST_D         KEY_ARG_NUM
      else:                                          [ CANC_OPN ]   [ RE_KEY ]
    LAST_DD:
      is_dig(.):             .|val*10 + get_dig(.)   LAST_D         KEY_ARG_NUM
      else:                                          [ DONE_ARG ]   [ RE_KEY ]
    LAST_D:
      is_dig(.):             .|val*10 + get_dig(.)   [ DONE_ARG ]   KEY_ARG_NUM
      else:                                          [ DONE_ARG ]   [ RE_KEY ]

    // Dangling from RUN/SST
    ADDRESS: SKIP_LBL:                               [ CANC_OPN ]   [ RE_KEY ]


KeyType handleStep(int step)
  assert step in 0..99

  // Some definitions
  opn = operations.last
  opr = opn.operator

  case opn.parse_state:
    COMPLETE:
      assert(false)
    OPERATOR:

    // Condition                  new inv|code        new state     ret_value

      is(INV) || is(INV2):        ~opr.inv|.          .             KEY_MOD_INV
      is_op(.):                   .|step              [ DONE_OPR ]  KEY_OP
      is(LBL):                                        SKIP_LBL      KEY_LBL_BEG
      else:  // Skip 2nd, 2nd', SST, Nop, Ind                       KEY_IGNORED
    SKIP_LBL:                                         OPERATOR      KEY_LBL_ARG

    // Condition                  type|value          state         ret_value

    ARG_UNK:
      case arg_kind(.):
        ARG_KIND_ADDRESS:         .|.                 ADDRESS       [ RE_HNDL ]
        ARG_KIND_DD():            NUM|step            [ DONE_ARG ]  KEY_ARG_NUM
        ARG_KIND_D:
          is(Ind):                IND|.               ARG_IND       KEY_MOD_IND
          else:                   NUM|step            [ DONE_ARG ]  KEY_ARG_NUM
        ARG_KIND_SBR:
          is_usr(.):              LBL|step            [ DONE_ARG ]  KEY_ARG_LBL
          is(SBR):                .|.                 ADDRESS       KEY_PGM_SBR
          is(2nd) || is(SST):                                       KEY_IGNORED
          else:                                       [ CANC_OPN ]  [ RE_HNDL ]
    ARG_IND:                      .|step              [ DONE_ARG ]  KEY_ARG_NUM
    ADDRESS:
      is(Ind):                    IND|.               LAST_DD       KEY_MOD_IND
      is_dig(.):                  NUM|step            LAST_DD       KEY_ARG_NUM
      is_label(.):                LBL|step            [ DONE_ARG ]  KEY_ARG_LBL
      is_op(.):                                       [ CANC_OPN ]  [ RE_HNDL ]
      else: return  // Skip 2nd, 2n', SST                           KEY_IGNORED
    LAST_DD:                      .|val*100 + step    [DONE_ARG]    KEY_ARG_NUM
    LAST_D:   // Should happen rarely, going from EVAL to SST
                                  .|val*10 + step/10  [DONE_ARG]    KEY_ARG_NUM
                                  handleStep(step % 10)


== Types of Operators ==

Arguments
  NONE
  D       = *DD or D
  DD      = *DD or DD
  ADDRESS = *DD or DDD or Label
  SBR     = USR or SBR ADDRESS

Examples
      CLR    25
      x=t    72 ADDRESS
      Dsz    82 ADDRESS
      STO    42 DD
      StFlg  56 D
  INV Lnx   -23
      Pgm    36 DD SBR    (RUN mode, straight DD)


== Test cases ==

x^2
INV Lnx
STO 00
STO *00
STO 0 Lnx
Stflg 0
Lbl A
INV SBR
x=t 123

