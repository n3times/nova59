Parser


== API ==

// Given a stream of key presses and program steps, the parser generates a
// stream of structured operations.
Parser
  Operation operations[]   // An ever growing array. Last/current may be empty.

  bool sec  // 2nd key is pressed (EVAL/LRN modes).

  // Updates the parser after a key has been pressed (EVAL/LRN modes).
  // Params: row in 1..9, col in 1..5.
  // Returns the code and type of key that has been pressed.
  Key keyPressed(Mode mode, int row, int col)

  // Updates the parser after the step has been handled (RUN/SST modes).
  // Param: code in 1..99.
  // Returns the code and type for the step.
  Key handleStep(int step)

Mode - Enum
  MODE_LRN MODE_EVAL MODE_RUN

Key
  KeyType type
  int value

KeyType - Enum
  KEY_MOD_SEC  // 2nd in EVAL/LRN
  KEY_OPR_INV  // INV or INV2 modifier key
  KEY_OPR      // An operator key
  KEY_OPD_IND  // Ind modifier key
  KEY_OPD_DIG  // 1 or 2 digits used as part of the operand
  KEY_OPD_LBL  // A label used as operand
  KEY_SKIP     // Can be 2ND, 2N', IND, NOP, LBL or SST
  KEY_LBL_BEG  // Beginning of label ("Lbl" in "Lbl STO")
  KEY_LBL_END  // End of label ("STO" in "Lbl STO")
  KEY_EVL_SST  // SST has been pressed in EVAL mode

Operation
  ParseState parse_state
  Operator operator
  Operand operands[]      // A growing array of length 0, 1 or 2

ParseState - Enum
  OPERATOR ARG_UNK SKIP_LBL       // OPERATOR
  ARG_IND LAST_DD LAST_D ADDRESS  // ARGUMENTS     
  COMPLETE

Operator
  bool inv
  int code        // 0 to 99

Operand
  OperandType type  // Indicates how to interpret the argument value
  int value         // 0 to 999: opcode for label or address or register...

OperandType - Enum
  UNK IND LBL NUM

OperandKind - Enum
  OPD_KIND_ADDRESS  // DDD, *DD or LBL
  OPD_KIND_D        // D or *DD
  OPD_KIND_DD       // DD (or *DD in EVAL/LRN modes)
  OPD_KIND_SBR      // usr or SBR address

== Helper functions ==

int get_code(bool sec, int row, int col)  // 0..99
int get_dig(bool sec, int row, int col) = get_code(.)  // and is_dig(.)
bool is_dig(bool sec, int row, int col) = get_code(.) in 0..9

// Anything but 2nd INV Ind 2n' IN' NOP LBl (SST in RUN/EVAL)
bool is_op(int code)
// Anything but 0..9, 2nd, 2n', Ind, LRN, SST, BST, Del, Ins
bool is_label(int code)
bool is_usr(int code) = code in 10..19

int arg_count(Operator operator)  // 0, 1 or 2

void cancel_operation()
  add new empty operation  // Previous operation remains incomplete
  keyPressed(row, col)     // Preserving sec

void done_arg()
  if current operation has additional operands
    add new arg
  else
    current_operation.parse_state = COMPLETE
    add new empty operation

void done_arg_requeue()
  done_arg()
  handleStep(step) or keyPressed(row, col)  // Preserving sec


== Implementation ==

KeyType keyPressed(Mode mode, int row, int col)
  assert row in 1..9 && col in 1..5

  mode == EVAL && self.mode == LRN: cancelOperationIfPending()
  self.mode = mode

  // Some definitions
  opn = operations.last
  opr = opn.operator

  is(2nd): ~opn.sec                                                 KEY_MOD_SEC
  is(SST) && mode == EVAL:                                          KEY_EVL_SST

  case opn.parse_state:
    COMPLETE: assert(false)

    // Condition             new inv|code            new state      ret_value
    OPERATOR:
      is(INV):               ~inv|.                  .              KEY_OPR_INV
      is_op(.):              .|get_code(.)           [ DONE_OPR ]   KEY_OPR
      is(LBL):                                       SKIP_LBL       KEY_LBL_BEG
      else:  // Skip Ind, Nop                                       KEY_SKIP
    SKIP_LBL:                                        OPERATOR       KEY_LBL_END

    // Condition             new type|value          new state      ret_value
    ARG_UNK:
      is(Ind):               IND|.                   ARG_IND        KEY_OPD_IND
      is_dig(.):
        case arg_kind(.):
          OPD_KIND_ADDRESS:  NUM|get_dig(.)          LAST_DD        KEY_OPD_DIG
          OPD_KIND_DD:       NUM|get_dig(.)          LAST_D         KEY_OPD_DIG
          OPD_KIND_D:        NUM|get_dig(.)          [ DONE_ARG ]   KEY_OPD_DIG
      is_label(.) && arg_kind(.) == OP_KIND_ADDRESS:
                             LBL|get_code(.)         [ DONE_ARG ]   KEY_ARG_LBL
      else:  // Program editing                      [ CANC_OPN ]   [ RE_KEY ]
    ARG_IND:
      is(Ind):               UNK|.                   ARG_UNK        KEY_OPD_IND
      is_dig(.):             .|get_dig(.)            LAST_D         KEY_OPD_DIG
      else:                                          [ CANC_OPN ]   [ RE_KEY ]
    LAST_DD:
      is_dig(.):             .|val*10 + get_dig(.)   LAST_D         KEY_OPD_DIG
      else:                                          [ DONE_ARG ]   [ RE_KEY ]
    LAST_D:
      is_dig(.):             .|val*10 + get_dig(.)   [ DONE_ARG ]   KEY_OPD_DIG
      else:                                          [ DONE_ARG ]   [ RE_KEY ]

    // Dangling from RUN
    ADDRESS:                                         [ CANC_OPN ]   [ RE_KEY ]


KeyType handleStep(int step)
  assert step in 0..99

  // Some definitions
  opn = operations.last
  opr = opn.operator

  case opn.parse_state:
    COMPLETE: assert(false)

    // Condition                  new inv|code        new state     ret_value
    OPERATOR:
      is(INV) || is(INV2):        ~opr.inv|.          .             KEY_OPR_INV
      is_op(.):                   .|step              [ DONE_OPR ]  KEY_OPR
      is(LBL):                                        SKIP_LBL      KEY_LBL_BEG
      else:  // Skip 2nd, 2nd', SST, Nop, Ind                       KEY_SKIP
    SKIP_LBL:                                         OPERATOR      KEY_LBL_END

    // Condition                  type|value          state         ret_value
    ARG_UNK:
      case arg_kind(.):
        OPD_KIND_ADDRESS:         .|.                 ADDRESS       [ RE_HNDL ]
        OPD_KIND_DD:              NUM|step            [ DONE_ARG ]  KEY_OPD_DIG
        OPD_KIND_D:
          is(Ind):                IND|.               ARG_IND       KEY_OPD_IND
          else:                   NUM|step            [ DONE_ARG ]  KEY_OPD_DIG
        OPD_KIND_SBR:
          is_usr(.):              LBL|step            [ DONE_ARG ]  KEY_ARG_LBL
          is(SBR):                .|.                 ADDRESS       KEY_PGM_SBR
          is(2nd) || is(SST):                                       KEY_SKIP
          else:                                       [ CANC_OPN ]  [ RE_HNDL ]
    ARG_IND:                      .|step              [ DONE_ARG ]  KEY_OPD_DIG
    ADDRESS:
      is(Ind):                    IND|.               LAST_DD       KEY_OPD_IND
      is_dig(.):                  NUM|step            LAST_DD       KEY_OPD_DIG
      is_label(.):                LBL|step            [ DONE_ARG ]  KEY_ARG_LBL
      is_op(.):                                       [ CANC_OPN ]  [ RE_HNDL ]
      else:  // 2nd, 2n', SST                                       KEY_SKIP
    LAST_DD:                      .|val*100 + step    [ DONE_ARG ]  KEY_OPD_DIG
    LAST_D:  // Dangling EVAL to RUN (w/SST)          [ DONE_ARG ]  [ RE_HNDL ]
    ///LAST_D:   // Should happen rarely, going from EVAL to RUN(SST)
    ///                           .|val*10 + step/10  [DONE_ARG]    KEY_OPD_DIG
    ///                           handleStep(step % 10)

